// Code generated by webidl-bind. DO NOT EDIT.

// +build !js

package javascript

import js "github.com/gowebapi/webapi/core/js"

// using following types:

// source idl files:
// javascript.idl
// promises.idl

// transform files:
// javascript.go.md
// promises.go.md

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// callback: ArrayCompareFunction
type ArrayCompareFunctionFunc func(a js.Value, b js.Value) int

// ArrayCompareFunction is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type ArrayCompareFunction js.Func

func ArrayCompareFunctionToJS(callback ArrayCompareFunctionFunc) *ArrayCompareFunction {
	if callback == nil {
		return nil
	}
	ret := ArrayCompareFunction(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any a
			_p1 js.Value // javascript: any b
		)
		_p0 = args[0]
		_p1 = args[1]
		_returned := callback(_p0, _p1)
		_converted := _returned
		return _converted
	}))
	return &ret
}

func ArrayCompareFunctionFromJS(_value js.Value) ArrayCompareFunctionFunc {
	return func(a js.Value, b js.Value) (_result int) {
		var (
			_args [2]interface{}
			_end  int
		)
		_p0 := a
		_args[0] = _p0
		_end++
		_p1 := b
		_args[1] = _p1
		_end++
		_returned := _value.Invoke(_args[0:_end]...)
		var (
			_converted int // javascript: long
		)
		_converted = (_returned).Int()
		_result = _converted
		return
	}
}

// callback: ArrayForEachCallback
type ArrayForEachCallbackFunc func(value js.Value, index int, array *Array)

// ArrayForEachCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type ArrayForEachCallback js.Func

func ArrayForEachCallbackToJS(callback ArrayForEachCallbackFunc) *ArrayForEachCallback {
	if callback == nil {
		return nil
	}
	ret := ArrayForEachCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any value
			_p1 int      // javascript: long index
			_p2 *Array   // javascript: Array array
		)
		_p0 = args[0]
		_p1 = (args[1]).Int()
		_p2 = ArrayFromJS(args[2])
		callback(_p0, _p1, _p2)

		// returning no return value
		return nil
	}))
	return &ret
}

func ArrayForEachCallbackFromJS(_value js.Value) ArrayForEachCallbackFunc {
	return func(value js.Value, index int, array *Array) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_p1 := index
		_args[1] = _p1
		_end++
		_p2 := array.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: ArrayMapCallback
type ArrayMapCallbackFunc func(value js.Value, index int, array *Array) interface{}

// ArrayMapCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type ArrayMapCallback js.Func

func ArrayMapCallbackToJS(callback ArrayMapCallbackFunc) *ArrayMapCallback {
	if callback == nil {
		return nil
	}
	ret := ArrayMapCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any value
			_p1 int      // javascript: long index
			_p2 *Array   // javascript: Array array
		)
		_p0 = args[0]
		_p1 = (args[1]).Int()
		_p2 = ArrayFromJS(args[2])
		_returned := callback(_p0, _p1, _p2)
		_converted := _returned
		return _converted
	}))
	return &ret
}

func ArrayMapCallbackFromJS(_value js.Value) ArrayMapCallbackFunc {
	return func(value js.Value, index int, array *Array) (_result interface{}) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_p1 := index
		_args[1] = _p1
		_end++
		_p2 := array.JSValue()
		_args[2] = _p2
		_end++
		_returned := _value.Invoke(_args[0:_end]...)
		var (
			_converted js.Value // javascript: any
		)
		_converted = _returned
		_result = _converted
		return
	}
}

// callback: ArrayMapFn
type ArrayMapFnFunc func(value js.Value) interface{}

// ArrayMapFn is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type ArrayMapFn js.Func

func ArrayMapFnToJS(callback ArrayMapFnFunc) *ArrayMapFn {
	if callback == nil {
		return nil
	}
	ret := ArrayMapFn(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any value
		)
		_p0 = args[0]
		_returned := callback(_p0)
		_converted := _returned
		return _converted
	}))
	return &ret
}

func ArrayMapFnFromJS(_value js.Value) ArrayMapFnFunc {
	return func(value js.Value) (_result interface{}) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_returned := _value.Invoke(_args[0:_end]...)
		var (
			_converted js.Value // javascript: any
		)
		_converted = _returned
		_result = _converted
		return
	}
}

// callback: ArrayReduceCallback
type ArrayReduceCallbackFunc func(accumulator js.Value, currentValue js.Value, currentIndex int, array *Array) interface{}

// ArrayReduceCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type ArrayReduceCallback js.Func

func ArrayReduceCallbackToJS(callback ArrayReduceCallbackFunc) *ArrayReduceCallback {
	if callback == nil {
		return nil
	}
	ret := ArrayReduceCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any accumulator
			_p1 js.Value // javascript: any currentValue
			_p2 int      // javascript: long currentIndex
			_p3 *Array   // javascript: Array array
		)
		_p0 = args[0]
		_p1 = args[1]
		_p2 = (args[2]).Int()
		_p3 = ArrayFromJS(args[3])
		_returned := callback(_p0, _p1, _p2, _p3)
		_converted := _returned
		return _converted
	}))
	return &ret
}

func ArrayReduceCallbackFromJS(_value js.Value) ArrayReduceCallbackFunc {
	return func(accumulator js.Value, currentValue js.Value, currentIndex int, array *Array) (_result interface{}) {
		var (
			_args [4]interface{}
			_end  int
		)
		_p0 := accumulator
		_args[0] = _p0
		_end++
		_p1 := currentValue
		_args[1] = _p1
		_end++
		_p2 := currentIndex
		_args[2] = _p2
		_end++
		_p3 := array.JSValue()
		_args[3] = _p3
		_end++
		_returned := _value.Invoke(_args[0:_end]...)
		var (
			_converted js.Value // javascript: any
		)
		_converted = _returned
		_result = _converted
		return
	}
}

// callback: ArrayTestCallback
type ArrayTestCallbackFunc func(element js.Value, index int, array *Array) bool

// ArrayTestCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type ArrayTestCallback js.Func

func ArrayTestCallbackToJS(callback ArrayTestCallbackFunc) *ArrayTestCallback {
	if callback == nil {
		return nil
	}
	ret := ArrayTestCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any element
			_p1 int      // javascript: long index
			_p2 *Array   // javascript: Array array
		)
		_p0 = args[0]
		_p1 = (args[1]).Int()
		_p2 = ArrayFromJS(args[2])
		_returned := callback(_p0, _p1, _p2)
		_converted := _returned
		return _converted
	}))
	return &ret
}

func ArrayTestCallbackFromJS(_value js.Value) ArrayTestCallbackFunc {
	return func(element js.Value, index int, array *Array) (_result bool) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := element
		_args[0] = _p0
		_end++
		_p1 := index
		_args[1] = _p1
		_end++
		_p2 := array.JSValue()
		_args[2] = _p2
		_end++
		_returned := _value.Invoke(_args[0:_end]...)
		var (
			_converted bool // javascript: boolean
		)
		_converted = (_returned).Bool()
		_result = _converted
		return
	}
}

// callback: ArrayValueCallback
type ArrayValueCallbackFunc func(value js.Value, index int, array *Array) interface{}

// ArrayValueCallback is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type ArrayValueCallback js.Func

func ArrayValueCallbackToJS(callback ArrayValueCallbackFunc) *ArrayValueCallback {
	if callback == nil {
		return nil
	}
	ret := ArrayValueCallback(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any value
			_p1 int      // javascript: long index
			_p2 *Array   // javascript: Array array
		)
		_p0 = args[0]
		_p1 = (args[1]).Int()
		_p2 = ArrayFromJS(args[2])
		_returned := callback(_p0, _p1, _p2)
		_converted := _returned
		return _converted
	}))
	return &ret
}

func ArrayValueCallbackFromJS(_value js.Value) ArrayValueCallbackFunc {
	return func(value js.Value, index int, array *Array) (_result interface{}) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_p1 := index
		_args[1] = _p1
		_end++
		_p2 := array.JSValue()
		_args[2] = _p2
		_end++
		_returned := _value.Invoke(_args[0:_end]...)
		var (
			_converted js.Value // javascript: any
		)
		_converted = _returned
		_result = _converted
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseArrayBufferOnFulfilledFunc func(value *ArrayBuffer)

// PromiseArrayBufferOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseArrayBufferOnFulfilled js.Func

func PromiseArrayBufferOnFulfilledToJS(callback PromiseArrayBufferOnFulfilledFunc) *PromiseArrayBufferOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseArrayBufferOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *ArrayBuffer // javascript: ArrayBuffer value
		)
		_p0 = ArrayBufferFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseArrayBufferOnFulfilledFromJS(_value js.Value) PromiseArrayBufferOnFulfilledFunc {
	return func(value *ArrayBuffer) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseArrayBufferOnRejectedFunc func(reason js.Value)

// PromiseArrayBufferOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseArrayBufferOnRejected js.Func

func PromiseArrayBufferOnRejectedToJS(callback PromiseArrayBufferOnRejectedFunc) *PromiseArrayBufferOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseArrayBufferOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseArrayBufferOnRejectedFromJS(_value js.Value) PromiseArrayBufferOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseBoolOnFulfilledFunc func(value bool)

// PromiseBoolOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseBoolOnFulfilled js.Func

func PromiseBoolOnFulfilledToJS(callback PromiseBoolOnFulfilledFunc) *PromiseBoolOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseBoolOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 bool // javascript: boolean value
		)
		_p0 = (args[0]).Bool()
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseBoolOnFulfilledFromJS(_value js.Value) PromiseBoolOnFulfilledFunc {
	return func(value bool) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseBoolOnRejectedFunc func(reason js.Value)

// PromiseBoolOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseBoolOnRejected js.Func

func PromiseBoolOnRejectedToJS(callback PromiseBoolOnRejectedFunc) *PromiseBoolOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseBoolOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseBoolOnRejectedFromJS(_value js.Value) PromiseBoolOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseDataViewOnFulfilledFunc func(value *DataView)

// PromiseDataViewOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseDataViewOnFulfilled js.Func

func PromiseDataViewOnFulfilledToJS(callback PromiseDataViewOnFulfilledFunc) *PromiseDataViewOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseDataViewOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *DataView // javascript: DataView value
		)
		_p0 = DataViewFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseDataViewOnFulfilledFromJS(_value js.Value) PromiseDataViewOnFulfilledFunc {
	return func(value *DataView) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseDataViewOnRejectedFunc func(reason js.Value)

// PromiseDataViewOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseDataViewOnRejected js.Func

func PromiseDataViewOnRejectedToJS(callback PromiseDataViewOnRejectedFunc) *PromiseDataViewOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseDataViewOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseDataViewOnRejectedFromJS(_value js.Value) PromiseDataViewOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseFinally
type PromiseFinallyFunc func()

// PromiseFinally is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseFinally js.Func

func PromiseFinallyToJS(callback PromiseFinallyFunc) *PromiseFinally {
	if callback == nil {
		return nil
	}
	ret := PromiseFinally(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var ()
		callback()

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseFinallyFromJS(_value js.Value) PromiseFinallyFunc {
	return func() {
		var (
			_args [0]interface{}
			_end  int
		)
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseFrozenArrayOnFulfilledFunc func(value *FrozenArray)

// PromiseFrozenArrayOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseFrozenArrayOnFulfilled js.Func

func PromiseFrozenArrayOnFulfilledToJS(callback PromiseFrozenArrayOnFulfilledFunc) *PromiseFrozenArrayOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseFrozenArrayOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *FrozenArray // javascript: FrozenArray value
		)
		_p0 = FrozenArrayFromJS(args[0])
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseFrozenArrayOnFulfilledFromJS(_value js.Value) PromiseFrozenArrayOnFulfilledFunc {
	return func(value *FrozenArray) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseFrozenArrayOnRejectedFunc func(reason js.Value)

// PromiseFrozenArrayOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseFrozenArrayOnRejected js.Func

func PromiseFrozenArrayOnRejectedToJS(callback PromiseFrozenArrayOnRejectedFunc) *PromiseFrozenArrayOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseFrozenArrayOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseFrozenArrayOnRejectedFromJS(_value js.Value) PromiseFrozenArrayOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseIntOnFulfilledFunc func(value int)

// PromiseIntOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseIntOnFulfilled js.Func

func PromiseIntOnFulfilledToJS(callback PromiseIntOnFulfilledFunc) *PromiseIntOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseIntOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 int // javascript: long value
		)
		_p0 = (args[0]).Int()
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseIntOnFulfilledFromJS(_value js.Value) PromiseIntOnFulfilledFunc {
	return func(value int) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseIntOnRejectedFunc func(reason js.Value)

// PromiseIntOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseIntOnRejected js.Func

func PromiseIntOnRejectedToJS(callback PromiseIntOnRejectedFunc) *PromiseIntOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseIntOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseIntOnRejectedFromJS(_value js.Value) PromiseIntOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseOnFulfilled
type PromiseOnFulfilledFunc func(value js.Value)

// PromiseOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseOnFulfilled js.Func

func PromiseOnFulfilledToJS(callback PromiseOnFulfilledFunc) *PromiseOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any value
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseOnFulfilledFromJS(_value js.Value) PromiseOnFulfilledFunc {
	return func(value js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseOnRejected
type PromiseOnRejectedFunc func(reason js.Value)

// PromiseOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseOnRejected js.Func

func PromiseOnRejectedToJS(callback PromiseOnRejectedFunc) *PromiseOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseOnRejectedFromJS(_value js.Value) PromiseOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseSequenceStringOnFulfilledFunc func(value []string)

// PromiseSequenceStringOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseSequenceStringOnFulfilled js.Func

func PromiseSequenceStringOnFulfilledToJS(callback PromiseSequenceStringOnFulfilledFunc) *PromiseSequenceStringOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseSequenceStringOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 []string // javascript: sequence<DOMString> value
		)
		__length0 := args[0].Length()
		__array0 := make([]string, __length0, __length0)
		for __idx0 := 0; __idx0 < __length0; __idx0++ {
			var __seq_out0 string
			__seq_in0 := args[0].Index(__idx0)
			__seq_out0 = (__seq_in0).String()
			__array0[__idx0] = __seq_out0
		}
		_p0 = __array0
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseSequenceStringOnFulfilledFromJS(_value js.Value) PromiseSequenceStringOnFulfilledFunc {
	return func(value []string) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := js.Global().Get("Array").New(len(value))
		for __idx0, __seq_in0 := range value {
			__seq_out0 := __seq_in0
			_p0.SetIndex(__idx0, __seq_out0)
		}
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseSequenceStringOnRejectedFunc func(reason js.Value)

// PromiseSequenceStringOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseSequenceStringOnRejected js.Func

func PromiseSequenceStringOnRejectedToJS(callback PromiseSequenceStringOnRejectedFunc) *PromiseSequenceStringOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseSequenceStringOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseSequenceStringOnRejectedFromJS(_value js.Value) PromiseSequenceStringOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseStringOnFulfilledFunc func(value string)

// PromiseStringOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseStringOnFulfilled js.Func

func PromiseStringOnFulfilledToJS(callback PromiseStringOnFulfilledFunc) *PromiseStringOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseStringOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 string // javascript: DOMString value
		)
		_p0 = (args[0]).String()
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseStringOnFulfilledFromJS(_value js.Value) PromiseStringOnFulfilledFunc {
	return func(value string) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseStringOnRejectedFunc func(reason js.Value)

// PromiseStringOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseStringOnRejected js.Func

func PromiseStringOnRejectedToJS(callback PromiseStringOnRejectedFunc) *PromiseStringOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseStringOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseStringOnRejectedFromJS(_value js.Value) PromiseStringOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseVoidOnFulfilled
type PromiseVoidOnFulfilledFunc func()

// PromiseVoidOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseVoidOnFulfilled js.Func

func PromiseVoidOnFulfilledToJS(callback PromiseVoidOnFulfilledFunc) *PromiseVoidOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseVoidOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var ()
		callback()

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseVoidOnFulfilledFromJS(_value js.Value) PromiseVoidOnFulfilledFunc {
	return func() {
		var (
			_args [0]interface{}
			_end  int
		)
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseVoidOnRejected
type PromiseVoidOnRejectedFunc func(reason js.Value)

// PromiseVoidOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseVoidOnRejected js.Func

func PromiseVoidOnRejectedToJS(callback PromiseVoidOnRejectedFunc) *PromiseVoidOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseVoidOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)

		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseVoidOnRejectedFromJS(_value js.Value) PromiseVoidOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: ArrayEntryValue
type ArrayEntryValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ArrayEntryValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// ArrayEntryValueFromJS is allocating a new
// ArrayEntryValue object and copy all values from
// input javascript object
func ArrayEntryValueFromJS(value js.Wrapper) *ArrayEntryValue {
	input := value.JSValue()
	var out ArrayEntryValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := input.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := input.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: ArrayKeyValue
type ArrayKeyValue struct {
	Value int
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ArrayKeyValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// ArrayKeyValueFromJS is allocating a new
// ArrayKeyValue object and copy all values from
// input javascript object
func ArrayKeyValueFromJS(value js.Wrapper) *ArrayKeyValue {
	input := value.JSValue()
	var out ArrayKeyValue
	var (
		value0 int  // javascript: long {value Value value}
		value1 bool // javascript: boolean {done Done done}
	)
	value0 = (input.Get("value")).Int()
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: ArrayValueIteratorValue
type ArrayValueIteratorValue struct {
	Value js.Value
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *ArrayValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// ArrayValueIteratorValueFromJS is allocating a new
// ArrayValueIteratorValue object and copy all values from
// input javascript object
func ArrayValueIteratorValueFromJS(value js.Wrapper) *ArrayValueIteratorValue {
	input := value.JSValue()
	var out ArrayValueIteratorValue
	var (
		value0 js.Value // javascript: any {value Value value}
		value1 bool     // javascript: boolean {done Done done}
	)
	value0 = input.Get("value")
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// class: Array
type Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Array) JSValue() js.Value {
	return _this.Value_JS
}

// ArrayFromJS is casting a js.Wrapper into Array.
func ArrayFromJS(value js.Wrapper) *Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Array{}
	ret.Value_JS = input
	return ret
}

func From(arrayLike interface{}, mapFn *ArrayMapFn, thisArg interface{}) (_result *Array) {
	_klass := js.Global().Get("Array")
	_method := _klass.Get("from")
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := arrayLike
	_args[0] = _p0
	_end++
	if mapFn != nil {

		var __callback1 js.Value
		if mapFn != nil {
			__callback1 = (*mapFn).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	if thisArg != nil {
		_p2 := thisArg
		_args[2] = _p2
		_end++
	}
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func IsArray(value interface{}) (_result bool) {
	_klass := js.Global().Get("Array")
	_method := _klass.Get("isArray")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func NewArray(elements ...interface{}) (_result *Array) {
	_klass := js.Global().Get("Array")
	var (
		_args []interface{} = make([]interface{}, 0+len(elements))
		_end  int
	)
	for _, __in := range elements {
		__out := __in
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type int (idl: long).
func (_this *Array) Length() int {
	var ret int
	value := _this.Value_JS.Get("length")
	ret = (value).Int()
	return ret
}

func (_this *Array) Index(index uint) (_result js.Value) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *Array) SetIndex(index uint, value interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := index
	_args[0] = _p0
	_end++
	_p1 := value
	_args[1] = _p1
	_end++
	_this.Value_JS.Call("", _args[0:_end]...)
	return
}

func (_this *Array) Concat(arrayOrValues interface{}) (_result *Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := arrayOrValues
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("concat", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) CopyWithin(target int, start *int, end *int) (_result *Array) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := target
	_args[0] = _p0
	_end++
	if start != nil {

		var _p1 interface{}
		if start != nil {
			_p1 = *(start)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	if end != nil {

		var _p2 interface{}
		if end != nil {
			_p2 = *(end)
		} else {
			_p2 = nil
		}
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("copyWithin", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Entries() (_result *ArrayEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *ArrayEntryIterator // javascript: ArrayEntryIterator _what_return_name
	)
	_converted = ArrayEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Every(callback *ArrayTestCallback, thisArg interface{}) (_result bool) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("every", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func (_this *Array) Fill(value interface{}, start *int, end *int) (_result *Array) {
	var (
		_args [3]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	if start != nil {

		var _p1 interface{}
		if start != nil {
			_p1 = *(start)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	if end != nil {

		var _p2 interface{}
		if end != nil {
			_p2 = *(end)
		} else {
			_p2 = nil
		}
		_args[2] = _p2
		_end++
	}
	_returned := _this.Value_JS.Call("fill", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Filter(callback *ArrayTestCallback, thisArg interface{}) (_result *Array) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("filter", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Find(callback *ArrayTestCallback, thisArg interface{}) (_result js.Value) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("find", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *Array) FindIndex(callback *ArrayTestCallback, thisArg interface{}) (_result int) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("findIndex", _args[0:_end]...)
	var (
		_converted int // javascript: long _what_return_name
	)
	_converted = (_returned).Int()
	_result = _converted
	return
}

func (_this *Array) Flat(depth *int) (_result *Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	if depth != nil {

		var _p0 interface{}
		if depth != nil {
			_p0 = *(depth)
		} else {
			_p0 = nil
		}
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("flat", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) FlatMap(callback *ArrayValueCallback, thisArg interface{}) (_result *Array) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("flatMap", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) ForEach(callback *ArrayForEachCallback, thisArg interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *Array) Includes(valueToFind interface{}, fromIndex int) (_result bool) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := valueToFind
	_args[0] = _p0
	_end++
	_p1 := fromIndex
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("includes", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func (_this *Array) IndexOf(value interface{}, fromIndex int) (_result int) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_p1 := fromIndex
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("indexOf", _args[0:_end]...)
	var (
		_converted int // javascript: long _what_return_name
	)
	_converted = (_returned).Int()
	_result = _converted
	return
}

func (_this *Array) Join(separator *string) (_result string) {
	var (
		_args [1]interface{}
		_end  int
	)
	if separator != nil {

		var _p0 interface{}
		if separator != nil {
			_p0 = *(separator)
		} else {
			_p0 = nil
		}
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("join", _args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

func (_this *Array) Keys() (_result *ArrayKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *ArrayKeyIterator // javascript: ArrayKeyIterator _what_return_name
	)
	_converted = ArrayKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) LastIndexOf(searchElement interface{}, fromIndex *int) (_result int) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := searchElement
	_args[0] = _p0
	_end++
	if fromIndex != nil {

		var _p1 interface{}
		if fromIndex != nil {
			_p1 = *(fromIndex)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("lastIndexOf", _args[0:_end]...)
	var (
		_converted int // javascript: long _what_return_name
	)
	_converted = (_returned).Int()
	_result = _converted
	return
}

func (_this *Array) Map(callback *ArrayMapCallback, thisArg interface{}) (_result *Array) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("map", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Pop() (_result js.Value) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("pop", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *Array) Push(element1 interface{}, elementN ...interface{}) (_result int) {
	var (
		_args []interface{} = make([]interface{}, 1+len(elementN))
		_end  int
	)
	_p0 := element1
	_args[0] = _p0
	_end++
	for _, __in := range elementN {
		__out := __in
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("push", _args[0:_end]...)
	var (
		_converted int // javascript: long _what_return_name
	)
	_converted = (_returned).Int()
	_result = _converted
	return
}

func (_this *Array) Reduce(callback *ArrayReduceCallback, initailValue interface{}) (_result js.Value) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_p1 := initailValue
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("reduce", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *Array) ReduceRight(callback *ArrayReduceCallback, initailValue interface{}) (_result js.Value) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_p1 := initailValue
	_args[1] = _p1
	_end++
	_returned := _this.Value_JS.Call("reduceRight", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *Array) Reverse() (_result *Array) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("reverse", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Shift() (_result js.Value) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("shift", _args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func (_this *Array) Slice(begin *int, end *int) (_result *Array) {
	var (
		_args [2]interface{}
		_end  int
	)
	if begin != nil {

		var _p0 interface{}
		if begin != nil {
			_p0 = *(begin)
		} else {
			_p0 = nil
		}
		_args[0] = _p0
		_end++
	}
	if end != nil {

		var _p1 interface{}
		if end != nil {
			_p1 = *(end)
		} else {
			_p1 = nil
		}
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("slice", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Some(callback *ArrayTestCallback, thisArg interface{}) (_result bool) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if thisArg != nil {
		_p1 := thisArg
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("some", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func (_this *Array) Sort(compare *ArrayCompareFunction) (_result *Array) {
	var (
		_args [1]interface{}
		_end  int
	)
	if compare != nil {

		var __callback0 js.Value
		if compare != nil {
			__callback0 = (*compare).Value
		} else {
			__callback0 = js.Null()
		}
		_p0 := __callback0
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("sort", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Splice(start int, deleteCount int, itemsToAddAfterStart ...interface{}) (_result *Array) {
	var (
		_args []interface{} = make([]interface{}, 2+len(itemsToAddAfterStart))
		_end  int
	)
	_p0 := start
	_args[0] = _p0
	_end++
	_p1 := deleteCount
	_args[1] = _p1
	_end++
	for _, __in := range itemsToAddAfterStart {
		__out := __in
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("splice", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) ToLocaleString(locales *string) (_result string) {
	var (
		_args [1]interface{}
		_end  int
	)
	if locales != nil {

		var _p0 interface{}
		if locales != nil {
			_p0 = *(locales)
		} else {
			_p0 = nil
		}
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("toLocaleString", _args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

func (_this *Array) ToString() (_result string) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("toString", _args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

func (_this *Array) Unshift(element1 interface{}, elementN ...interface{}) (_result *Array) {
	var (
		_args []interface{} = make([]interface{}, 1+len(elementN))
		_end  int
	)
	_p0 := element1
	_args[0] = _p0
	_end++
	for _, __in := range elementN {
		__out := __in
		_args[_end] = __out
		_end++
	}
	_returned := _this.Value_JS.Call("unshift", _args[0:_end]...)
	var (
		_converted *Array // javascript: Array _what_return_name
	)
	_converted = ArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *Array) Values() (_result *ArrayValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *ArrayValueIterator // javascript: ArrayValueIterator _what_return_name
	)
	_converted = ArrayValueIteratorFromJS(_returned)
	_result = _converted
	return
}

// class: ArrayBuffer
type ArrayBuffer struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *ArrayBuffer) JSValue() js.Value {
	return _this.Value_JS
}

// ArrayBufferFromJS is casting a js.Wrapper into ArrayBuffer.
func ArrayBufferFromJS(value js.Wrapper) *ArrayBuffer {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ArrayBuffer{}
	ret.Value_JS = input
	return ret
}

// class: ArrayEntryIterator
type ArrayEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *ArrayEntryIterator) JSValue() js.Value {
	return _this.Value_JS
}

// ArrayEntryIteratorFromJS is casting a js.Wrapper into ArrayEntryIterator.
func ArrayEntryIteratorFromJS(value js.Wrapper) *ArrayEntryIterator {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ArrayEntryIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *ArrayEntryIterator) Next() (_result *ArrayEntryValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *ArrayEntryValue // javascript: ArrayEntryValue _what_return_name
	)
	_converted = ArrayEntryValueFromJS(_returned)
	_result = _converted
	return
}

// class: ArrayKeyIterator
type ArrayKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *ArrayKeyIterator) JSValue() js.Value {
	return _this.Value_JS
}

// ArrayKeyIteratorFromJS is casting a js.Wrapper into ArrayKeyIterator.
func ArrayKeyIteratorFromJS(value js.Wrapper) *ArrayKeyIterator {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ArrayKeyIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *ArrayKeyIterator) Next() (_result *ArrayKeyValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *ArrayKeyValue // javascript: ArrayKeyValue _what_return_name
	)
	_converted = ArrayKeyValueFromJS(_returned)
	_result = _converted
	return
}

// class: ArrayValueIterator
type ArrayValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *ArrayValueIterator) JSValue() js.Value {
	return _this.Value_JS
}

// ArrayValueIteratorFromJS is casting a js.Wrapper into ArrayValueIterator.
func ArrayValueIteratorFromJS(value js.Wrapper) *ArrayValueIterator {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &ArrayValueIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *ArrayValueIterator) Next() (_result *ArrayValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *ArrayValueIteratorValue // javascript: ArrayValueIteratorValue _what_return_name
	)
	_converted = ArrayValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// class: DataView
type DataView struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *DataView) JSValue() js.Value {
	return _this.Value_JS
}

// DataViewFromJS is casting a js.Wrapper into DataView.
func DataViewFromJS(value js.Wrapper) *DataView {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &DataView{}
	ret.Value_JS = input
	return ret
}

// class: Float32Array
type Float32Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Float32Array) JSValue() js.Value {
	return _this.Value_JS
}

// Float32ArrayFromJS is casting a js.Wrapper into Float32Array.
func Float32ArrayFromJS(value js.Wrapper) *Float32Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Float32Array{}
	ret.Value_JS = input
	return ret
}

// class: Float64Array
type Float64Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Float64Array) JSValue() js.Value {
	return _this.Value_JS
}

// Float64ArrayFromJS is casting a js.Wrapper into Float64Array.
func Float64ArrayFromJS(value js.Wrapper) *Float64Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Float64Array{}
	ret.Value_JS = input
	return ret
}

// class: FrozenArray
type FrozenArray struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *FrozenArray) JSValue() js.Value {
	return _this.Value_JS
}

// FrozenArrayFromJS is casting a js.Wrapper into FrozenArray.
func FrozenArrayFromJS(value js.Wrapper) *FrozenArray {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &FrozenArray{}
	ret.Value_JS = input
	return ret
}

// class: Int16Array
type Int16Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Int16Array) JSValue() js.Value {
	return _this.Value_JS
}

// Int16ArrayFromJS is casting a js.Wrapper into Int16Array.
func Int16ArrayFromJS(value js.Wrapper) *Int16Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Int16Array{}
	ret.Value_JS = input
	return ret
}

// class: Int32Array
type Int32Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Int32Array) JSValue() js.Value {
	return _this.Value_JS
}

// Int32ArrayFromJS is casting a js.Wrapper into Int32Array.
func Int32ArrayFromJS(value js.Wrapper) *Int32Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Int32Array{}
	ret.Value_JS = input
	return ret
}

// class: Int8Array
type Int8Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Int8Array) JSValue() js.Value {
	return _this.Value_JS
}

// Int8ArrayFromJS is casting a js.Wrapper into Int8Array.
func Int8ArrayFromJS(value js.Wrapper) *Int8Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Int8Array{}
	ret.Value_JS = input
	return ret
}

// class: JavaScriptFunction
type JavaScriptFunction struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *JavaScriptFunction) JSValue() js.Value {
	return _this.Value_JS
}

// JavaScriptFunctionFromJS is casting a js.Wrapper into JavaScriptFunction.
func JavaScriptFunctionFromJS(value js.Wrapper) *JavaScriptFunction {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &JavaScriptFunction{}
	ret.Value_JS = input
	return ret
}

func NewJavaScriptFunction(argumentAndFunctionBody ...string) (_result *JavaScriptFunction) {
	_klass := js.Global().Get("JavaScriptFunction")
	var (
		_args []interface{} = make([]interface{}, 0+len(argumentAndFunctionBody))
		_end  int
	)
	for _, __in := range argumentAndFunctionBody {
		__out := __in
		_args[_end] = __out
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *JavaScriptFunction // javascript: JavaScriptFunction _what_return_name
	)
	_converted = JavaScriptFunctionFromJS(_returned)
	_result = _converted
	return
}

// Length returning attribute 'length' with
// type int (idl: long).
func (_this *JavaScriptFunction) Length() int {
	var ret int
	value := _this.Value_JS.Get("length")
	ret = (value).Int()
	return ret
}

// Name returning attribute 'name' with
// type string (idl: DOMString).
func (_this *JavaScriptFunction) Name() string {
	var ret string
	value := _this.Value_JS.Get("name")
	ret = (value).String()
	return ret
}

// GlobalThis returning attribute 'globalThis' with
// type Any (idl: any).
func GlobalThis() js.Value {
	var ret js.Value
	_klass := js.Global()
	value := _klass.Get("globalThis")
	ret = value
	return ret
}

func Eval(code string) (_result js.Value) {
	_klass := js.Global()
	_method := _klass.Get("eval")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := code
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted js.Value // javascript: any _what_return_name
	)
	_converted = _returned
	_result = _converted
	return
}

func IsFinite(value float64) (_result bool) {
	_klass := js.Global()
	_method := _klass.Get("isFinite")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func IsNaN(value float64) (_result bool) {
	_klass := js.Global()
	_method := _klass.Get("isNaN")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

func ParseFloat(value interface{}) (_result float64) {
	_klass := js.Global()
	_method := _klass.Get("parseFloat")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted float64 // javascript: double _what_return_name
	)
	_converted = (_returned).Float()
	_result = _converted
	return
}

func ParseInt(value interface{}, radix int) (_result int) {
	_klass := js.Global()
	_method := _klass.Get("parseInt")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := value
	_args[0] = _p0
	_end++
	_p1 := radix
	_args[1] = _p1
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted int // javascript: long _what_return_name
	)
	_converted = (_returned).Int()
	_result = _converted
	return
}

func DecodeURI(encodedURI string) (_result string) {
	_klass := js.Global()
	_method := _klass.Get("decodeURI")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := encodedURI
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

func DecodeURIComponent(encodedURI string) (_result string) {
	_klass := js.Global()
	_method := _klass.Get("decodeURIComponent")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := encodedURI
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

func EncodeURI(uri string) (_result string) {
	_klass := js.Global()
	_method := _klass.Get("encodeURI")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := uri
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

func EncodeURIComponent(uri string) (_result string) {
	_klass := js.Global()
	_method := _klass.Get("encodeURIComponent")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := uri
	_args[0] = _p0
	_end++
	_returned := _method.Invoke(_args[0:_end]...)
	var (
		_converted string // javascript: DOMString _what_return_name
	)
	_converted = (_returned).String()
	_result = _converted
	return
}

// class: object
type Object struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Object) JSValue() js.Value {
	return _this.Value_JS
}

// ObjectFromJS is casting a js.Wrapper into Object.
func ObjectFromJS(value js.Wrapper) *Object {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Object{}
	ret.Value_JS = input
	return ret
}

// class: Promise
type Promise struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Promise) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseFromJS is casting a js.Wrapper into Promise.
func PromiseFromJS(value js.Wrapper) *Promise {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Promise{}
	ret.Value_JS = input
	return ret
}

func (_this *Promise) Then(onFulfilled *PromiseOnFulfilled, onRejected *PromiseOnRejected) (_result *Promise) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *Promise // javascript: Promise _what_return_name
	)
	_converted = PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Promise) Catch(onRejected *PromiseOnRejected) (_result *Promise) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *Promise // javascript: Promise _what_return_name
	)
	_converted = PromiseFromJS(_returned)
	_result = _converted
	return
}

func (_this *Promise) Finally(onFinally *PromiseFinally) (_result *Promise) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *Promise // javascript: Promise _what_return_name
	)
	_converted = PromiseFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseArrayBuffer struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseArrayBuffer) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseArrayBufferFromJS is casting a js.Wrapper into PromiseArrayBuffer.
func PromiseArrayBufferFromJS(value js.Wrapper) *PromiseArrayBuffer {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseArrayBuffer{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseArrayBuffer) Then(onFulfilled *PromiseArrayBufferOnFulfilled, onRejected *PromiseArrayBufferOnRejected) (_result *PromiseArrayBuffer) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseArrayBuffer // javascript: Promise _what_return_name
	)
	_converted = PromiseArrayBufferFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseArrayBuffer) Catch(onRejected *PromiseArrayBufferOnRejected) (_result *PromiseArrayBuffer) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseArrayBuffer // javascript: Promise _what_return_name
	)
	_converted = PromiseArrayBufferFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseArrayBuffer) Finally(onFinally *PromiseFinally) (_result *PromiseArrayBuffer) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseArrayBuffer // javascript: Promise _what_return_name
	)
	_converted = PromiseArrayBufferFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseBool struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseBool) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseBoolFromJS is casting a js.Wrapper into PromiseBool.
func PromiseBoolFromJS(value js.Wrapper) *PromiseBool {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseBool{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseBool) Then(onFulfilled *PromiseBoolOnFulfilled, onRejected *PromiseBoolOnRejected) (_result *PromiseBool) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseBool // javascript: Promise _what_return_name
	)
	_converted = PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseBool) Catch(onRejected *PromiseBoolOnRejected) (_result *PromiseBool) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseBool // javascript: Promise _what_return_name
	)
	_converted = PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseBool) Finally(onFinally *PromiseFinally) (_result *PromiseBool) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseBool // javascript: Promise _what_return_name
	)
	_converted = PromiseBoolFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseDataView struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseDataView) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseDataViewFromJS is casting a js.Wrapper into PromiseDataView.
func PromiseDataViewFromJS(value js.Wrapper) *PromiseDataView {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseDataView{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseDataView) Then(onFulfilled *PromiseDataViewOnFulfilled, onRejected *PromiseDataViewOnRejected) (_result *PromiseDataView) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseDataView // javascript: Promise _what_return_name
	)
	_converted = PromiseDataViewFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseDataView) Catch(onRejected *PromiseDataViewOnRejected) (_result *PromiseDataView) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseDataView // javascript: Promise _what_return_name
	)
	_converted = PromiseDataViewFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseDataView) Finally(onFinally *PromiseFinally) (_result *PromiseDataView) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseDataView // javascript: Promise _what_return_name
	)
	_converted = PromiseDataViewFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseFrozenArray struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseFrozenArray) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseFrozenArrayFromJS is casting a js.Wrapper into PromiseFrozenArray.
func PromiseFrozenArrayFromJS(value js.Wrapper) *PromiseFrozenArray {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseFrozenArray{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseFrozenArray) Then(onFulfilled *PromiseFrozenArrayOnFulfilled, onRejected *PromiseFrozenArrayOnRejected) (_result *PromiseFrozenArray) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseFrozenArray // javascript: Promise _what_return_name
	)
	_converted = PromiseFrozenArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseFrozenArray) Catch(onRejected *PromiseFrozenArrayOnRejected) (_result *PromiseFrozenArray) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseFrozenArray // javascript: Promise _what_return_name
	)
	_converted = PromiseFrozenArrayFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseFrozenArray) Finally(onFinally *PromiseFinally) (_result *PromiseFrozenArray) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseFrozenArray // javascript: Promise _what_return_name
	)
	_converted = PromiseFrozenArrayFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseInt struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseInt) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseIntFromJS is casting a js.Wrapper into PromiseInt.
func PromiseIntFromJS(value js.Wrapper) *PromiseInt {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseInt{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseInt) Then(onFulfilled *PromiseIntOnFulfilled, onRejected *PromiseIntOnRejected) (_result *PromiseInt) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseInt // javascript: Promise _what_return_name
	)
	_converted = PromiseIntFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseInt) Catch(onRejected *PromiseIntOnRejected) (_result *PromiseInt) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseInt // javascript: Promise _what_return_name
	)
	_converted = PromiseIntFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseInt) Finally(onFinally *PromiseFinally) (_result *PromiseInt) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseInt // javascript: Promise _what_return_name
	)
	_converted = PromiseIntFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseSequenceString struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseSequenceString) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseSequenceStringFromJS is casting a js.Wrapper into PromiseSequenceString.
func PromiseSequenceStringFromJS(value js.Wrapper) *PromiseSequenceString {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseSequenceString{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseSequenceString) Then(onFulfilled *PromiseSequenceStringOnFulfilled, onRejected *PromiseSequenceStringOnRejected) (_result *PromiseSequenceString) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseSequenceString // javascript: Promise _what_return_name
	)
	_converted = PromiseSequenceStringFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseSequenceString) Catch(onRejected *PromiseSequenceStringOnRejected) (_result *PromiseSequenceString) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseSequenceString // javascript: Promise _what_return_name
	)
	_converted = PromiseSequenceStringFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseSequenceString) Finally(onFinally *PromiseFinally) (_result *PromiseSequenceString) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseSequenceString // javascript: Promise _what_return_name
	)
	_converted = PromiseSequenceStringFromJS(_returned)
	_result = _converted
	return
}

// class: Promise
type PromiseString struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseString) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseStringFromJS is casting a js.Wrapper into PromiseString.
func PromiseStringFromJS(value js.Wrapper) *PromiseString {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseString{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseString) Then(onFulfilled *PromiseStringOnFulfilled, onRejected *PromiseStringOnRejected) (_result *PromiseString) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseString // javascript: Promise _what_return_name
	)
	_converted = PromiseStringFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseString) Catch(onRejected *PromiseStringOnRejected) (_result *PromiseString) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseString // javascript: Promise _what_return_name
	)
	_converted = PromiseStringFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseString) Finally(onFinally *PromiseFinally) (_result *PromiseString) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseString // javascript: Promise _what_return_name
	)
	_converted = PromiseStringFromJS(_returned)
	_result = _converted
	return
}

// class: PromiseVoid
type PromiseVoid struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseVoid) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseVoidFromJS is casting a js.Wrapper into PromiseVoid.
func PromiseVoidFromJS(value js.Wrapper) *PromiseVoid {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &PromiseVoid{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseVoid) Then(onFulfilled *PromiseVoidOnFulfilled, onRejected *PromiseVoidOnRejected) (_result *PromiseVoid) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseVoid) Catch(onRejected *PromiseVoidOnRejected) (_result *PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseVoid) Finally(onFinally *PromiseFinally) (_result *PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

// class: Uint16Array
type Uint16Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Uint16Array) JSValue() js.Value {
	return _this.Value_JS
}

// Uint16ArrayFromJS is casting a js.Wrapper into Uint16Array.
func Uint16ArrayFromJS(value js.Wrapper) *Uint16Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Uint16Array{}
	ret.Value_JS = input
	return ret
}

// class: Uint32Array
type Uint32Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Uint32Array) JSValue() js.Value {
	return _this.Value_JS
}

// Uint32ArrayFromJS is casting a js.Wrapper into Uint32Array.
func Uint32ArrayFromJS(value js.Wrapper) *Uint32Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Uint32Array{}
	ret.Value_JS = input
	return ret
}

// class: Uint8Array
type Uint8Array struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Uint8Array) JSValue() js.Value {
	return _this.Value_JS
}

// Uint8ArrayFromJS is casting a js.Wrapper into Uint8Array.
func Uint8ArrayFromJS(value js.Wrapper) *Uint8Array {
	input := value.JSValue()
	if typ := input.Type(); typ == js.TypeNull || typ == js.TypeUndefined {
		return nil
	}
	ret := &Uint8Array{}
	ret.Value_JS = input
	return ret
}
