// Code generated by webidl-bind. DO NOT EDIT.

package keyboard

import "syscall/js"

import (
	"github.com/gowebapi/webapi/javascript"
)

// using following types:
// javascript.PromiseFinally
// javascript.PromiseVoid

// source idl files:
// keyboard-lock.idl
// keyboard-map.idl
// promises.idl

// transform files:
// keyboard-lock.go.md
// keyboard-map.go.md
// promises.go.md

// ReleasableApiResource is used to release underlaying
// allocated resources.
type ReleasableApiResource interface {
	Release()
}

type releasableApiResourceList []ReleasableApiResource

func (a releasableApiResourceList) Release() {
	for _, v := range a {
		v.Release()
	}
}

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// callback: KeyboardLayoutMapForEach
type LayoutMapForEachFunc func(currentValue string, currentKey string, listObj *LayoutMap)

// LayoutMapForEach is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type LayoutMapForEach js.Func

func LayoutMapForEachToJS(callback LayoutMapForEachFunc) *LayoutMapForEach {
	if callback == nil {
		return nil
	}
	ret := LayoutMapForEach(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 string     // javascript: DOMString currentValue
			_p1 string     // javascript: DOMString currentKey
			_p2 *LayoutMap // javascript: KeyboardLayoutMap listObj
		)
		_p0 = (args[0]).String()
		_p1 = (args[1]).String()
		_p2 = LayoutMapFromJS(args[2])
		callback(_p0, _p1, _p2)
		// returning no return value
		return nil
	}))
	return &ret
}

func LayoutMapForEachFromJS(_value js.Value) LayoutMapForEachFunc {
	return func(currentValue string, currentKey string, listObj *LayoutMap) {
		var (
			_args [3]interface{}
			_end  int
		)
		_p0 := currentValue
		_args[0] = _p0
		_end++
		_p1 := currentKey
		_args[1] = _p1
		_end++
		_p2 := listObj.JSValue()
		_args[2] = _p2
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnFulfilled
type PromiseLayoutMapOnFulfilledFunc func(value *LayoutMap)

// PromiseLayoutMapOnFulfilled is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseLayoutMapOnFulfilled js.Func

func PromiseLayoutMapOnFulfilledToJS(callback PromiseLayoutMapOnFulfilledFunc) *PromiseLayoutMapOnFulfilled {
	if callback == nil {
		return nil
	}
	ret := PromiseLayoutMapOnFulfilled(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 *LayoutMap // javascript: KeyboardLayoutMap value
		)
		_p0 = LayoutMapFromJS(args[0])
		callback(_p0)
		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseLayoutMapOnFulfilledFromJS(_value js.Value) PromiseLayoutMapOnFulfilledFunc {
	return func(value *LayoutMap) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := value.JSValue()
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// callback: PromiseTemplateOnRejected
type PromiseLayoutMapOnRejectedFunc func(reason js.Value)

// PromiseLayoutMapOnRejected is a javascript function type.
//
// Call Release() when done to release resouces
// allocated to this type.
type PromiseLayoutMapOnRejected js.Func

func PromiseLayoutMapOnRejectedToJS(callback PromiseLayoutMapOnRejectedFunc) *PromiseLayoutMapOnRejected {
	if callback == nil {
		return nil
	}
	ret := PromiseLayoutMapOnRejected(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		var (
			_p0 js.Value // javascript: any reason
		)
		_p0 = args[0]
		callback(_p0)
		// returning no return value
		return nil
	}))
	return &ret
}

func PromiseLayoutMapOnRejectedFromJS(_value js.Value) PromiseLayoutMapOnRejectedFunc {
	return func(reason js.Value) {
		var (
			_args [1]interface{}
			_end  int
		)
		_p0 := reason
		_args[0] = _p0
		_end++
		_value.Invoke(_args[0:_end]...)
		return
	}
}

// dictionary: KeyboardLayoutMapEntryIteratorValue
type LayoutMapEntryIteratorValue struct {
	Value []js.Value
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *LayoutMapEntryIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Value))
	for __idx0, __seq_in0 := range _this.Value {
		__seq_out0 := __seq_in0
		value0.SetIndex(__idx0, __seq_out0)
	}
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// LayoutMapEntryIteratorValueFromJS is allocating a new
// LayoutMapEntryIteratorValue object and copy all values from
// input javascript object
func LayoutMapEntryIteratorValueFromJS(value js.Wrapper) *LayoutMapEntryIteratorValue {
	input := value.JSValue()
	var out LayoutMapEntryIteratorValue
	var (
		value0 []js.Value // javascript: sequence<any> {value Value value}
		value1 bool       // javascript: boolean {done Done done}
	)
	__length0 := input.Get("value").Length()
	__array0 := make([]js.Value, __length0, __length0)
	for __idx0 := 0; __idx0 < __length0; __idx0++ {
		var __seq_out0 js.Value
		__seq_in0 := input.Get("value").Index(__idx0)
		__seq_out0 = __seq_in0
		__array0[__idx0] = __seq_out0
	}
	value0 = __array0
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: KeyboardLayoutMapKeyIteratorValue
type LayoutMapKeyIteratorValue struct {
	Value string
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *LayoutMapKeyIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// LayoutMapKeyIteratorValueFromJS is allocating a new
// LayoutMapKeyIteratorValue object and copy all values from
// input javascript object
func LayoutMapKeyIteratorValueFromJS(value js.Wrapper) *LayoutMapKeyIteratorValue {
	input := value.JSValue()
	var out LayoutMapKeyIteratorValue
	var (
		value0 string // javascript: DOMString {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = (input.Get("value")).String()
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// dictionary: KeyboardLayoutMapValueIteratorValue
type LayoutMapValueIteratorValue struct {
	Value string
	Done  bool
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *LayoutMapValueIteratorValue) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Value
	out.Set("value", value0)
	value1 := _this.Done
	out.Set("done", value1)
	return out
}

// LayoutMapValueIteratorValueFromJS is allocating a new
// LayoutMapValueIteratorValue object and copy all values from
// input javascript object
func LayoutMapValueIteratorValueFromJS(value js.Wrapper) *LayoutMapValueIteratorValue {
	input := value.JSValue()
	var out LayoutMapValueIteratorValue
	var (
		value0 string // javascript: DOMString {value Value value}
		value1 bool   // javascript: boolean {done Done done}
	)
	value0 = (input.Get("value")).String()
	out.Value = value0
	value1 = (input.Get("done")).Bool()
	out.Done = value1
	return &out
}

// interface: Keyboard
type Keyboard struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *Keyboard) JSValue() js.Value {
	return _this.Value_JS
}

// KeyboardFromJS is casting a js.Wrapper into Keyboard.
func KeyboardFromJS(value js.Wrapper) *Keyboard {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &Keyboard{}
	ret.Value_JS = input
	return ret
}

func (_this *Keyboard) Lock(keyCodes []string) (_result *javascript.PromiseVoid) {
	var (
		_args [1]interface{}
		_end  int
	)
	if keyCodes != nil {
		_p0 := js.Global().Get("Array").New(len(keyCodes))
		for __idx0, __seq_in0 := range keyCodes {
			__seq_out0 := __seq_in0
			_p0.SetIndex(__idx0, __seq_out0)
		}
		_args[0] = _p0
		_end++
	}
	_returned := _this.Value_JS.Call("lock", _args[0:_end]...)
	var (
		_converted *javascript.PromiseVoid // javascript: PromiseVoid _what_return_name
	)
	_converted = javascript.PromiseVoidFromJS(_returned)
	_result = _converted
	return
}

func (_this *Keyboard) Unlock() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("unlock", _args[0:_end]...)
	return
}

func (_this *Keyboard) GetLayoutMap() (_result *PromiseLayoutMap) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("getLayoutMap", _args[0:_end]...)
	var (
		_converted *PromiseLayoutMap // javascript: Promise _what_return_name
	)
	_converted = PromiseLayoutMapFromJS(_returned)
	_result = _converted
	return
}

// interface: KeyboardLayoutMap
type LayoutMap struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *LayoutMap) JSValue() js.Value {
	return _this.Value_JS
}

// LayoutMapFromJS is casting a js.Wrapper into LayoutMap.
func LayoutMapFromJS(value js.Wrapper) *LayoutMap {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &LayoutMap{}
	ret.Value_JS = input
	return ret
}

// Size returning attribute 'size' with
// type int (idl: long).
func (_this *LayoutMap) Size() int {
	var ret int
	value := _this.Value_JS.Get("size")
	ret = (value).Int()
	return ret
}

func (_this *LayoutMap) Entries() (_result *LayoutMapEntryIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("entries", _args[0:_end]...)
	var (
		_converted *LayoutMapEntryIterator // javascript: KeyboardLayoutMapEntryIterator _what_return_name
	)
	_converted = LayoutMapEntryIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *LayoutMap) ForEach(callback *LayoutMapForEach, optionalThisForCallbackArgument interface{}) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if callback != nil {
		__callback0 = (*callback).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if optionalThisForCallbackArgument != nil {
		_p1 := optionalThisForCallbackArgument
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("forEach", _args[0:_end]...)
	return
}

func (_this *LayoutMap) Keys() (_result *LayoutMapKeyIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("keys", _args[0:_end]...)
	var (
		_converted *LayoutMapKeyIterator // javascript: KeyboardLayoutMapKeyIterator _what_return_name
	)
	_converted = LayoutMapKeyIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *LayoutMap) Values() (_result *LayoutMapValueIterator) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("values", _args[0:_end]...)
	var (
		_converted *LayoutMapValueIterator // javascript: KeyboardLayoutMapValueIterator _what_return_name
	)
	_converted = LayoutMapValueIteratorFromJS(_returned)
	_result = _converted
	return
}

func (_this *LayoutMap) Get(key string) (_result *string) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("get", _args[0:_end]...)
	var (
		_converted *string // javascript: DOMString _what_return_name
	)
	if _returned.Type() != js.TypeNull && _returned.Type() != js.TypeUndefined {
		__tmp := (_returned).String()
		_converted = &__tmp
	}
	_result = _converted
	return
}

func (_this *LayoutMap) Has(key string) (_result bool) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := key
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("has", _args[0:_end]...)
	var (
		_converted bool // javascript: boolean _what_return_name
	)
	_converted = (_returned).Bool()
	_result = _converted
	return
}

// interface: KeyboardLayoutMapEntryIterator
type LayoutMapEntryIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *LayoutMapEntryIterator) JSValue() js.Value {
	return _this.Value_JS
}

// LayoutMapEntryIteratorFromJS is casting a js.Wrapper into LayoutMapEntryIterator.
func LayoutMapEntryIteratorFromJS(value js.Wrapper) *LayoutMapEntryIterator {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &LayoutMapEntryIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *LayoutMapEntryIterator) Next() (_result *LayoutMapEntryIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *LayoutMapEntryIteratorValue // javascript: KeyboardLayoutMapEntryIteratorValue _what_return_name
	)
	_converted = LayoutMapEntryIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// interface: KeyboardLayoutMapKeyIterator
type LayoutMapKeyIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *LayoutMapKeyIterator) JSValue() js.Value {
	return _this.Value_JS
}

// LayoutMapKeyIteratorFromJS is casting a js.Wrapper into LayoutMapKeyIterator.
func LayoutMapKeyIteratorFromJS(value js.Wrapper) *LayoutMapKeyIterator {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &LayoutMapKeyIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *LayoutMapKeyIterator) Next() (_result *LayoutMapKeyIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *LayoutMapKeyIteratorValue // javascript: KeyboardLayoutMapKeyIteratorValue _what_return_name
	)
	_converted = LayoutMapKeyIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// interface: KeyboardLayoutMapValueIterator
type LayoutMapValueIterator struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *LayoutMapValueIterator) JSValue() js.Value {
	return _this.Value_JS
}

// LayoutMapValueIteratorFromJS is casting a js.Wrapper into LayoutMapValueIterator.
func LayoutMapValueIteratorFromJS(value js.Wrapper) *LayoutMapValueIterator {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &LayoutMapValueIterator{}
	ret.Value_JS = input
	return ret
}

func (_this *LayoutMapValueIterator) Next() (_result *LayoutMapValueIteratorValue) {
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _this.Value_JS.Call("next", _args[0:_end]...)
	var (
		_converted *LayoutMapValueIteratorValue // javascript: KeyboardLayoutMapValueIteratorValue _what_return_name
	)
	_converted = LayoutMapValueIteratorValueFromJS(_returned)
	_result = _converted
	return
}

// interface: Promise
type PromiseLayoutMap struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *PromiseLayoutMap) JSValue() js.Value {
	return _this.Value_JS
}

// PromiseLayoutMapFromJS is casting a js.Wrapper into PromiseLayoutMap.
func PromiseLayoutMapFromJS(value js.Wrapper) *PromiseLayoutMap {
	input := value.JSValue()
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &PromiseLayoutMap{}
	ret.Value_JS = input
	return ret
}

func (_this *PromiseLayoutMap) Then(onFulfilled *PromiseLayoutMapOnFulfilled, onRejected *PromiseLayoutMapOnRejected) (_result *PromiseLayoutMap) {
	var (
		_args [2]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFulfilled != nil {
		__callback0 = (*onFulfilled).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	if onRejected != nil {

		var __callback1 js.Value
		if onRejected != nil {
			__callback1 = (*onRejected).Value
		} else {
			__callback1 = js.Null()
		}
		_p1 := __callback1
		_args[1] = _p1
		_end++
	}
	_returned := _this.Value_JS.Call("then", _args[0:_end]...)
	var (
		_converted *PromiseLayoutMap // javascript: Promise _what_return_name
	)
	_converted = PromiseLayoutMapFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseLayoutMap) Catch(onRejected *PromiseLayoutMapOnRejected) (_result *PromiseLayoutMap) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onRejected != nil {
		__callback0 = (*onRejected).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("catch", _args[0:_end]...)
	var (
		_converted *PromiseLayoutMap // javascript: Promise _what_return_name
	)
	_converted = PromiseLayoutMapFromJS(_returned)
	_result = _converted
	return
}

func (_this *PromiseLayoutMap) Finally(onFinally *javascript.PromiseFinally) (_result *PromiseLayoutMap) {
	var (
		_args [1]interface{}
		_end  int
	)

	var __callback0 js.Value
	if onFinally != nil {
		__callback0 = (*onFinally).Value
	} else {
		__callback0 = js.Null()
	}
	_p0 := __callback0
	_args[0] = _p0
	_end++
	_returned := _this.Value_JS.Call("finally", _args[0:_end]...)
	var (
		_converted *PromiseLayoutMap // javascript: Promise _what_return_name
	)
	_converted = PromiseLayoutMapFromJS(_returned)
	_result = _converted
	return
}
