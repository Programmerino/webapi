// Code generated by webidlgenerator. DO NOT EDIT.

// +build !js

package channel

import js "github.com/gowebapi/webapi/core/failjs"

import "github.com/gowebapi/webapi/javascript"
import "github.com/gowebapi/webapi/dom/domcore"
import "github.com/gowebapi/webapi/fileapi"

// using following types:
// domcore.Event
// domcore.EventHandler
// domcore.EventTarget
// fileapi.Blob
// javascript.ArrayBuffer
// javascript.FrozenArray
// javascript.Object

// ReleasableApiResource is used to release underlaying
// allocated resources.
type ReleasableApiResource interface {
	Release()
}

type releasableApiResourceList []ReleasableApiResource

func (a releasableApiResourceList) Release() {
	for _, v := range a {
		v.Release()
	}
}

// workaround for compiler error
func unused(value interface{}) {
	// TODO remove this method
}

type Union struct {
	Value js.Value
}

func (u *Union) JSValue() js.Value {
	return u.Value
}

func UnionFromJS(value js.Value) *Union {
	return &Union{Value: value}
}

// enum: BinaryType
type BinaryType int

const (
	Blob BinaryType = iota
	Arraybuffer
)

var binaryTypeToWasmTable = []string{
	"blob", "arraybuffer",
}

var binaryTypeFromWasmTable = map[string]BinaryType{
	"blob": Blob, "arraybuffer": Arraybuffer,
}

// JSValue is converting this enum into a java object
func (this *BinaryType) JSValue() js.Value {
	return js.ValueOf(this.Value())
}

// Value is converting this into javascript defined
// string value
func (this BinaryType) Value() string {
	idx := int(this)
	if idx >= 0 && idx < len(binaryTypeToWasmTable) {
		return binaryTypeToWasmTable[idx]
	}
	panic("unknown input value")
}

// BinaryTypeFromJS is converting a javascript value into
// a BinaryType enum value.
func BinaryTypeFromJS(value js.Value) BinaryType {
	key := value.String()
	conv, ok := binaryTypeFromWasmTable[key]
	if !ok {
		panic("unable to convert '" + key + "'")
	}
	return conv
}

// dictionary: MessageEventInit
type MessageEventInit struct {
	Data        js.Value
	Origin      string
	LastEventId string
	Source      *Union
	Ports       []*MessagePort
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *MessageEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.Data
	out.Set("data", value0)
	value1 := _this.Origin
	out.Set("origin", value1)
	value2 := _this.LastEventId
	out.Set("lastEventId", value2)
	value3 := _this.Source.JSValue()
	out.Set("source", value3)
	value4 := js.Global().Get("Array").New(len(_this.Ports))
	for __idx, __in := range _this.Ports {
		__out := __in.JSValue()
		value4.SetIndex(__idx, __out)
	}
	out.Set("ports", value4)
	return out
}

// MessageEventInitFromJS is allocating a new
// MessageEventInit object and copy all values from
// input javascript object
func MessageEventInitFromJS(input js.Value) *MessageEventInit {
	var out MessageEventInit
	var (
		out0 js.Value       // javascript: any {data Data data}
		out1 string         // javascript: USVString {origin Origin origin}
		out2 string         // javascript: DOMString {lastEventId LastEventId lastEventId}
		out3 *Union         // javascript: Union {source Source source}
		out4 []*MessagePort // javascript: idl-sequence {ports Ports ports}
	)
	out0 = input.Get("data")
	out.Data = out0
	out1 = (input.Get("origin")).String()
	out.Origin = out1
	out2 = (input.Get("lastEventId")).String()
	out.LastEventId = out2
	if input.Get("source").Type() != js.TypeNull {
		out3 = UnionFromJS(input.Get("source"))
	}
	out.Source = out3
	__length4 := input.Get("ports").Length()
	__array4 := make([]*MessagePort, __length4, __length4)
	for __idx := 0; __idx < __length4; __idx++ {
		var __out *MessagePort
		__in := input.Get("ports").Index(__idx)
		__out = MessagePortFromJS(__in)
		__array4[__idx] = __out
	}
	out4 = __array4
	out.Ports = out4
	return &out
}

// dictionary: CloseEventInit
type CloseEventInit struct {
	WasClean bool
	Code     int
	Reason   string
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *CloseEventInit) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := _this.WasClean
	out.Set("wasClean", value0)
	value1 := _this.Code
	out.Set("code", value1)
	value2 := _this.Reason
	out.Set("reason", value2)
	return out
}

// CloseEventInitFromJS is allocating a new
// CloseEventInit object and copy all values from
// input javascript object
func CloseEventInitFromJS(input js.Value) *CloseEventInit {
	var out CloseEventInit
	var (
		out0 bool   // javascript: boolean {wasClean WasClean wasClean}
		out1 int    // javascript: unsigned short {code Code code}
		out2 string // javascript: USVString {reason Reason reason}
	)
	out0 = (input.Get("wasClean")).Bool()
	out.WasClean = out0
	out1 = (input.Get("code")).Int()
	out.Code = out1
	out2 = (input.Get("reason")).String()
	out.Reason = out2
	return &out
}

// dictionary: PostMessageOptions
type PostMessageOptions struct {
	Transfer []*javascript.Object
}

// JSValue is allocating a new javasript object and copy
// all values
func (_this *PostMessageOptions) JSValue() js.Value {
	out := js.Global().Get("Object").New()
	value0 := js.Global().Get("Array").New(len(_this.Transfer))
	for __idx, __in := range _this.Transfer {
		__out := __in.JSValue()
		value0.SetIndex(__idx, __out)
	}
	out.Set("transfer", value0)
	return out
}

// PostMessageOptionsFromJS is allocating a new
// PostMessageOptions object and copy all values from
// input javascript object
func PostMessageOptionsFromJS(input js.Value) *PostMessageOptions {
	var out PostMessageOptions
	var (
		out0 []*javascript.Object // javascript: idl-sequence {transfer Transfer transfer}
	)
	__length0 := input.Get("transfer").Length()
	__array0 := make([]*javascript.Object, __length0, __length0)
	for __idx := 0; __idx < __length0; __idx++ {
		var __out *javascript.Object
		__in := input.Get("transfer").Index(__idx)
		__out = javascript.ObjectFromJS(__in)
		__array0[__idx] = __out
	}
	out0 = __array0
	out.Transfer = out0
	return &out
}

// interface: MessageEvent
type MessageEvent struct {
	domcore.Event
}

// MessageEventFromJS is casting a js.Value into MessageEvent.
func MessageEventFromJS(input js.Value) *MessageEvent {
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &MessageEvent{}
	ret.Value_JS = input
	return ret
}

func NewMessageEvent(_type string, eventInitDict *MessageEventInit) (_result *MessageEvent) {
	_klass := js.Global().Get("MessageEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *MessageEvent // javascript: MessageEvent _what_return_name
	)
	_converted = MessageEventFromJS(_returned)
	_result = _converted
	return
}

// Data returning attribute 'data' with
// type js.Value (idl: any).
func (_this *MessageEvent) Data() js.Value {
	var ret js.Value
	value := _this.Value_JS.Get("data")
	ret = value
	return ret
}

// Origin returning attribute 'origin' with
// type string (idl: USVString).
func (_this *MessageEvent) Origin() string {
	var ret string
	value := _this.Value_JS.Get("origin")
	ret = (value).String()
	return ret
}

// LastEventId returning attribute 'lastEventId' with
// type string (idl: DOMString).
func (_this *MessageEvent) LastEventId() string {
	var ret string
	value := _this.Value_JS.Get("lastEventId")
	ret = (value).String()
	return ret
}

// Source returning attribute 'source' with
// type Union (idl: Union).
func (_this *MessageEvent) Source() *Union {
	var ret *Union
	value := _this.Value_JS.Get("source")
	if value.Type() != js.TypeNull {
		ret = UnionFromJS(value)
	}
	return ret
}

// Ports returning attribute 'ports' with
// type javascript.FrozenArray (idl: FrozenArray).
func (_this *MessageEvent) Ports() *javascript.FrozenArray {
	var ret *javascript.FrozenArray
	value := _this.Value_JS.Get("ports")
	ret = javascript.FrozenArrayFromJS(value)
	return ret
}

func (_this *MessageEvent) InitMessageEvent(_type string, bubbles *bool, cancelable *bool, data js.Value, origin *string, lastEventId *string, source *Union, ports *[]*MessagePort) {
	var (
		_args [8]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if bubbles != nil {
		_p1 := bubbles
		_args[1] = _p1
		_end++
	}
	if cancelable != nil {
		_p2 := cancelable
		_args[2] = _p2
		_end++
	}
	if data.Type() != js.TypeUndefined {
		_p3 := data
		_args[3] = _p3
		_end++
	}
	if origin != nil {
		_p4 := origin
		_args[4] = _p4
		_end++
	}
	if lastEventId != nil {
		_p5 := lastEventId
		_args[5] = _p5
		_end++
	}
	if source != nil {
		_p6 := source.JSValue()
		_args[6] = _p6
		_end++
	}
	if ports != nil {
		_p7 := js.Global().Get("Array").New(len(*ports))
		for __idx, __in := range *ports {
			__out := __in.JSValue()
			_p7.SetIndex(__idx, __out)
		}
		_args[7] = _p7
		_end++
	}
	_this.Value_JS.Call("initMessageEvent", _args[0:_end]...)
	return
}

// interface: WebSocket
type WebSocket struct {
	domcore.EventTarget
}

// WebSocketFromJS is casting a js.Value into WebSocket.
func WebSocketFromJS(input js.Value) *WebSocket {
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &WebSocket{}
	ret.Value_JS = input
	return ret
}

const CONNECTING int = 0
const OPEN int = 1
const CLOSING int = 2
const CLOSED int = 3

func NewWebSocket(url string, protocols *Union) (_result *WebSocket) {
	_klass := js.Global().Get("WebSocket")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := url
	_args[0] = _p0
	_end++
	if protocols != nil {
		_p1 := protocols.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *WebSocket // javascript: WebSocket _what_return_name
	)
	_converted = WebSocketFromJS(_returned)
	_result = _converted
	return
}

// Url returning attribute 'url' with
// type string (idl: USVString).
func (_this *WebSocket) Url() string {
	var ret string
	value := _this.Value_JS.Get("url")
	ret = (value).String()
	return ret
}

// ReadyState returning attribute 'readyState' with
// type int (idl: unsigned short).
func (_this *WebSocket) ReadyState() int {
	var ret int
	value := _this.Value_JS.Get("readyState")
	ret = (value).Int()
	return ret
}

// BufferedAmount returning attribute 'bufferedAmount' with
// type int (idl: unsigned long long).
func (_this *WebSocket) BufferedAmount() int {
	var ret int
	value := _this.Value_JS.Get("bufferedAmount")
	ret = (value).Int()
	return ret
}

// Onopen returning attribute 'onopen' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) Onopen() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onopen")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnopen setting attribute 'onopen' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) SetOnopen(value *js.Callback) {
	var __callback3 js.Value
	if value != nil {
		__callback3 = (*value).Value
	} else {
		__callback3 = js.Null()
	}
	input := __callback3
	_this.Value_JS.Set("onopen", input)
}

// Onerror returning attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) Onerror() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onerror")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnerror setting attribute 'onerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) SetOnerror(value *js.Callback) {
	var __callback4 js.Value
	if value != nil {
		__callback4 = (*value).Value
	} else {
		__callback4 = js.Null()
	}
	input := __callback4
	_this.Value_JS.Set("onerror", input)
}

// Onclose returning attribute 'onclose' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) Onclose() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onclose")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnclose setting attribute 'onclose' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) SetOnclose(value *js.Callback) {
	var __callback5 js.Value
	if value != nil {
		__callback5 = (*value).Value
	} else {
		__callback5 = js.Null()
	}
	input := __callback5
	_this.Value_JS.Set("onclose", input)
}

// Extensions returning attribute 'extensions' with
// type string (idl: DOMString).
func (_this *WebSocket) Extensions() string {
	var ret string
	value := _this.Value_JS.Get("extensions")
	ret = (value).String()
	return ret
}

// Protocol returning attribute 'protocol' with
// type string (idl: DOMString).
func (_this *WebSocket) Protocol() string {
	var ret string
	value := _this.Value_JS.Get("protocol")
	ret = (value).String()
	return ret
}

// Onmessage returning attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) Onmessage() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onmessage")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmessage setting attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *WebSocket) SetOnmessage(value *js.Callback) {
	var __callback8 js.Value
	if value != nil {
		__callback8 = (*value).Value
	} else {
		__callback8 = js.Null()
	}
	input := __callback8
	_this.Value_JS.Set("onmessage", input)
}

// BinaryType returning attribute 'binaryType' with
// type BinaryType (idl: BinaryType).
func (_this *WebSocket) BinaryType() BinaryType {
	var ret BinaryType
	value := _this.Value_JS.Get("binaryType")
	ret = BinaryTypeFromJS(value)
	return ret
}

// SetBinaryType setting attribute 'binaryType' with
// type BinaryType (idl: BinaryType).
func (_this *WebSocket) SetBinaryType(value BinaryType) {
	input := value.JSValue()
	_this.Value_JS.Set("binaryType", input)
}

func (_this *WebSocket) Close(code *int, reason *string) {
	var (
		_args [2]interface{}
		_end  int
	)
	if code != nil {
		_p0 := code
		_args[0] = _p0
		_end++
	}
	if reason != nil {
		_p1 := reason
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("close", _args[0:_end]...)
	return
}

func (_this *WebSocket) Send(data string) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

func (_this *WebSocket) Send2(data *fileapi.Blob) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

func (_this *WebSocket) Send3(data *javascript.ArrayBuffer) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

func (_this *WebSocket) Send4(data *Union) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := data.JSValue()
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("send", _args[0:_end]...)
	return
}

// interface: CloseEvent
type CloseEvent struct {
	domcore.Event
}

// CloseEventFromJS is casting a js.Value into CloseEvent.
func CloseEventFromJS(input js.Value) *CloseEvent {
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &CloseEvent{}
	ret.Value_JS = input
	return ret
}

func NewCloseEvent(_type string, eventInitDict *CloseEventInit) (_result *CloseEvent) {
	_klass := js.Global().Get("CloseEvent")
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := _type
	_args[0] = _p0
	_end++
	if eventInitDict != nil {
		_p1 := eventInitDict.JSValue()
		_args[1] = _p1
		_end++
	}
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *CloseEvent // javascript: CloseEvent _what_return_name
	)
	_converted = CloseEventFromJS(_returned)
	_result = _converted
	return
}

// WasClean returning attribute 'wasClean' with
// type bool (idl: boolean).
func (_this *CloseEvent) WasClean() bool {
	var ret bool
	value := _this.Value_JS.Get("wasClean")
	ret = (value).Bool()
	return ret
}

// Code returning attribute 'code' with
// type int (idl: unsigned short).
func (_this *CloseEvent) Code() int {
	var ret int
	value := _this.Value_JS.Get("code")
	ret = (value).Int()
	return ret
}

// Reason returning attribute 'reason' with
// type string (idl: USVString).
func (_this *CloseEvent) Reason() string {
	var ret string
	value := _this.Value_JS.Get("reason")
	ret = (value).String()
	return ret
}

// interface: MessageChannel
type MessageChannel struct {
	// Value_JS holds a reference to a javascript value
	Value_JS js.Value
}

func (_this *MessageChannel) JSValue() js.Value {
	return _this.Value_JS
}

// MessageChannelFromJS is casting a js.Value into MessageChannel.
func MessageChannelFromJS(input js.Value) *MessageChannel {
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &MessageChannel{}
	ret.Value_JS = input
	return ret
}

func NewMessageChannel() (_result *MessageChannel) {
	_klass := js.Global().Get("MessageChannel")
	var (
		_args [0]interface{}
		_end  int
	)
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *MessageChannel // javascript: MessageChannel _what_return_name
	)
	_converted = MessageChannelFromJS(_returned)
	_result = _converted
	return
}

// Port1 returning attribute 'port1' with
// type MessagePort (idl: MessagePort).
func (_this *MessageChannel) Port1() *MessagePort {
	var ret *MessagePort
	value := _this.Value_JS.Get("port1")
	ret = MessagePortFromJS(value)
	return ret
}

// Port2 returning attribute 'port2' with
// type MessagePort (idl: MessagePort).
func (_this *MessageChannel) Port2() *MessagePort {
	var ret *MessagePort
	value := _this.Value_JS.Get("port2")
	ret = MessagePortFromJS(value)
	return ret
}

// interface: MessagePort
type MessagePort struct {
	domcore.EventTarget
}

// MessagePortFromJS is casting a js.Value into MessagePort.
func MessagePortFromJS(input js.Value) *MessagePort {
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &MessagePort{}
	ret.Value_JS = input
	return ret
}

// Onmessage returning attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *MessagePort) Onmessage() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onmessage")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmessage setting attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *MessagePort) SetOnmessage(value *js.Callback) {
	var __callback0 js.Value
	if value != nil {
		__callback0 = (*value).Value
	} else {
		__callback0 = js.Null()
	}
	input := __callback0
	_this.Value_JS.Set("onmessage", input)
}

// Onmessageerror returning attribute 'onmessageerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *MessagePort) Onmessageerror() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onmessageerror")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmessageerror setting attribute 'onmessageerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *MessagePort) SetOnmessageerror(value *js.Callback) {
	var __callback1 js.Value
	if value != nil {
		__callback1 = (*value).Value
	} else {
		__callback1 = js.Null()
	}
	input := __callback1
	_this.Value_JS.Set("onmessageerror", input)
}

func (_this *MessagePort) PostMessage(message js.Value, transfer []*javascript.Object) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := message
	_args[0] = _p0
	_end++
	_p1 := js.Global().Get("Array").New(len(transfer))
	for __idx, __in := range transfer {
		__out := __in.JSValue()
		_p1.SetIndex(__idx, __out)
	}
	_args[1] = _p1
	_end++
	_this.Value_JS.Call("postMessage", _args[0:_end]...)
	return
}

func (_this *MessagePort) PostMessage2(message js.Value, options *PostMessageOptions) {
	var (
		_args [2]interface{}
		_end  int
	)
	_p0 := message
	_args[0] = _p0
	_end++
	if options != nil {
		_p1 := options.JSValue()
		_args[1] = _p1
		_end++
	}
	_this.Value_JS.Call("postMessage", _args[0:_end]...)
	return
}

func (_this *MessagePort) Start() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("start", _args[0:_end]...)
	return
}

func (_this *MessagePort) Close() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("close", _args[0:_end]...)
	return
}

// interface: BroadcastChannel
type BroadcastChannel struct {
	domcore.EventTarget
}

// BroadcastChannelFromJS is casting a js.Value into BroadcastChannel.
func BroadcastChannelFromJS(input js.Value) *BroadcastChannel {
	if input.Type() == js.TypeNull {
		return nil
	}
	ret := &BroadcastChannel{}
	ret.Value_JS = input
	return ret
}

func NewBroadcastChannel(name string) (_result *BroadcastChannel) {
	_klass := js.Global().Get("BroadcastChannel")
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := name
	_args[0] = _p0
	_end++
	_returned := _klass.New(_args[0:_end]...)
	var (
		_converted *BroadcastChannel // javascript: BroadcastChannel _what_return_name
	)
	_converted = BroadcastChannelFromJS(_returned)
	_result = _converted
	return
}

// Name returning attribute 'name' with
// type string (idl: DOMString).
func (_this *BroadcastChannel) Name() string {
	var ret string
	value := _this.Value_JS.Get("name")
	ret = (value).String()
	return ret
}

// Onmessage returning attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BroadcastChannel) Onmessage() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onmessage")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmessage setting attribute 'onmessage' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BroadcastChannel) SetOnmessage(value *js.Callback) {
	var __callback1 js.Value
	if value != nil {
		__callback1 = (*value).Value
	} else {
		__callback1 = js.Null()
	}
	input := __callback1
	_this.Value_JS.Set("onmessage", input)
}

// Onmessageerror returning attribute 'onmessageerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BroadcastChannel) Onmessageerror() domcore.EventHandler {
	var ret domcore.EventHandler
	value := _this.Value_JS.Get("onmessageerror")
	if value.Type() != js.TypeNull {
		ret = domcore.EventHandlerFromJS(value)
	}
	return ret
}

// SetOnmessageerror setting attribute 'onmessageerror' with
// type domcore.EventHandler (idl: EventHandlerNonNull).
func (_this *BroadcastChannel) SetOnmessageerror(value *js.Callback) {
	var __callback2 js.Value
	if value != nil {
		__callback2 = (*value).Value
	} else {
		__callback2 = js.Null()
	}
	input := __callback2
	_this.Value_JS.Set("onmessageerror", input)
}

func (_this *BroadcastChannel) PostMessage(message js.Value) {
	var (
		_args [1]interface{}
		_end  int
	)
	_p0 := message
	_args[0] = _p0
	_end++
	_this.Value_JS.Call("postMessage", _args[0:_end]...)
	return
}

func (_this *BroadcastChannel) Close() {
	var (
		_args [0]interface{}
		_end  int
	)
	_this.Value_JS.Call("close", _args[0:_end]...)
	return
}
